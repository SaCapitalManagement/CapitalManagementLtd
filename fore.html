<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Strategy Equity Curves</title>
  <style>
    .financial-dashboard-container * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    .financial-dashboard-container {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: transparent;
      line-height: 1.6;
      color: #2d3748;
      padding: 0;
      width: 100%;
      max-width: none;
      margin: 0;
    }

    /* Main Layout */
    .financial-dashboard-container .main-layout {
      display: grid;
      grid-template-columns: 3fr 2fr; /* ~60% chart, ~40% stats on desktop */
      gap: 16px;
      margin-bottom: 16px;
    }

    /* Chart Section */
    .financial-dashboard-container .chart-section {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 20px;
      border: 1px solid #e2e8f0;
    }

    .financial-dashboard-container .chart-title {
      font-size: 16px;
      font-weight: 600;
      color: #1a202c;
      margin-bottom: 0px;
      text-align: center;
    }

    .financial-dashboard-container .chart-container {
      width: 100%;
      height: 400px;
      position: relative;
      overflow: hidden;
    }

    .financial-dashboard-container .chart-container canvas {
      max-width: 100% !important;
      height: auto !important;
    }

    /* Statistics Column */
    .financial-dashboard-container .stats-column {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 16px;
      border: 1px solid #e2e8f0;
    }

    /* Statistics Grid - Exact match to image */
    .financial-dashboard-container .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .financial-dashboard-container .stat-item {
      background: #f1f3f6;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      padding: 12px;
      text-align: left;
    }

    .financial-dashboard-container .stat-label {
      font-size: 11px;
      color: #6b7280;
      font-weight: 500;
      margin-bottom: 2px;
      line-height: 1.2;
    }

    .financial-dashboard-container .stat-value {
      font-size: 14px;
      font-weight: 700;
      color: #1f2937;
      line-height: 1.2;
    }

    .financial-dashboard-container .stat-sublabel {
      font-size: 9px;
      color: #6b7280;
      font-weight: 400;
      margin-top: 1px;
      line-height: 1.2;
    }

    /* Special styling for specific stats */
    .financial-dashboard-container .stat-value.positive {
      color: #059669;
    }

    .financial-dashboard-container .stat-value.negative {
      color: #000000;
    }

    /* Monthly Table Section */
    .financial-dashboard-container .monthly-table-section {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      padding: 16px;
      border: 1px solid #e2e8f0;
      overflow-x: auto;
    }

    .financial-dashboard-container .monthly-table-title {
      font-size: 14px;
      font-weight: 600;
      color: #1a202c;
      margin-bottom: 8px;
    }

    /* Monthly table - exact styling from image */
    .financial-dashboard-container .monthly-table {
      width: 100%;
      border-collapse: collapse;
      font-family: Arial, sans-serif;
      font-size: 10px;
      margin: 0;
    }

    .financial-dashboard-container .monthly-table th {
      background-color: #ddffdd;
      color: #000;
      font-weight: bold;
      padding: 4px 3px;
      text-align: center;
      border: 1px solid #999;
      font-size: 9px;
    }

    .financial-dashboard-container .monthly-table td {
      padding: 3px 2px;
      text-align: center;
      border: 1px solid #ccc;
      font-size: 9px;
      font-weight: normal;
    }

    /* Year column styling */
    .financial-dashboard-container .monthly-table .year-column {
      font-weight: bold;
      color: #000;
      background-color: inherit;
    }

    /* Total and MaxDD columns */
    .financial-dashboard-container .monthly-table .total-column,
    .financial-dashboard-container .monthly-table .maxdd-column {
      font-weight: bold;
      color: #000;
    }

    /* Row alternating colors */
    .financial-dashboard-container .monthly-table tbody tr:nth-child(even) {
      background-color: #f0f0f0;
    }

    .financial-dashboard-container .monthly-table tbody tr:nth-child(odd) {
      background-color: #ffffff;
    }

    /* Performance color coding */
    .financial-dashboard-container .gain-positive {
      color: #000 !important;
    }

    .financial-dashboard-container .gain-negative {
      color: #ff0000 !important;
    }

    .financial-dashboard-container .gain-neutral {
      color: #000 !important;
    }

    /* AVG row special styling */
    .financial-dashboard-container .monthly-table .avg-row {
      background-color: #ddffdd !important;
    }

    .financial-dashboard-container .monthly-table .avg-row td {
      background-color: #ddffdd !important;
      font-weight: bold !important;
      color: #000 !important;
    }

    /* Loading state */
    .financial-dashboard-container .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 200px;
      color: #64748b;
      font-size: 14px;
    }

    /* Forecast banner styles removed */

    /* Responsive Design */
    @media (max-width: 768px) {
      .financial-dashboard-container .main-layout {
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .financial-dashboard-container {
        padding: 0;
        width: 100%;
        max-width: none;
        overflow-x: hidden;
      }

      .financial-dashboard-container .chart-section,
      .financial-dashboard-container .stats-column {
        padding: 12px;
        margin: 0;
        width: 100%;
        box-sizing: border-box;
      }

      .financial-dashboard-container .chart-container {
        height: 280px;
        width: 100%;
        overflow: hidden;
      }

      .financial-dashboard-container .chart-container canvas {
        max-width: 100% !important;
        width: 100% !important;
        height: 280px !important;
      }

      .financial-dashboard-container .stats-grid {
        grid-template-columns: 1fr 1fr;
        gap: 6px;
      }

      .financial-dashboard-container .stat-item {
        padding: 8px;
        font-size: 11px;
      }

      .financial-dashboard-container .stat-value {
        font-size: 12px;
      }

      .financial-dashboard-container .stat-label {
        font-size: 9px;
      }

      .financial-dashboard-container .stat-sublabel {
        font-size: 8px;
      }

      .financial-dashboard-container .monthly-table {
        font-size: 8px;
        min-width: 600px;
      }

      .financial-dashboard-container .monthly-table th,
      .financial-dashboard-container .monthly-table td {
        padding: 2px 1px;
        font-size: 7px;
      }

      .financial-dashboard-container .monthly-table-section {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }
    }

    @media (max-width: 480px) {
      .financial-dashboard-container {
        padding: 0;
        width: 100%;
        max-width: 100vw;
        overflow-x: hidden;
      }

      .financial-dashboard-container .chart-section,
      .financial-dashboard-container .stats-column,
      .financial-dashboard-container .monthly-table-section {
        padding: 8px;
        margin: 0;
        width: 100%;
        box-sizing: border-box;
      }

      .financial-dashboard-container .chart-container {
        height: 220px;
        width: 100%;
        overflow: hidden;
      }

      .financial-dashboard-container .chart-container canvas {
        max-width: 100% !important;
        width: 100% !important;
        height: 220px !important;
      }

      .financial-dashboard-container .stats-grid {
        grid-template-columns: 1fr;
        gap: 6px;
      }

      .financial-dashboard-container .stat-item {
        padding: 8px;
      }

      .financial-dashboard-container .stat-value {
        font-size: 11px;
      }

      .financial-dashboard-container .stat-label {
        font-size: 9px;
      }

      .financial-dashboard-container .stat-sublabel {
        font-size: 8px;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
</head>
<body>
  <div class="financial-dashboard-container">
    <div class="main-layout">
             <!-- Chart Section -->
       <div class="chart-section">
         <h2 class="chart-title">Strategy Equity Curve</h2>
         <div class="chart-container">
           <canvas id="equityChart" width="400" height="400"></canvas>
         </div>
        
        <div style="text-align: center; margin-top: 4px; font-size: 10px; color: #9ca3af; font-style: italic;">
          All results shown include trading costs in the calculations.
        </div>
       </div>

      <!-- Statistics Column - Dynamic content -->
      <div class="stats-column">
        <div id="statsPanel">
          <div class="loading">Loading statistics...</div>
        </div>
      </div>
    </div>


    <!-- Monthly Performance Table -->
    <div class="monthly-table-section">
      <h3 class="monthly-table-title">Combined Monthly Percent Gains</h3>
      <div id="monthlyTablePanel">
        <div class="loading">Loading monthly performance data...</div>
      </div>
    </div>
  </div>

  <script>
    // Helper to extract product handle from the iframe URL query string
    function getProductHandle() {
      const params = new URLSearchParams(window.location.search);
      const handle = params.get('handle');
      if (handle) return handle;
      const match = window.location.pathname.match(/products\/([^\/\?]+)/);
      return match && match[1] ? match[1] : null;
    }

    // Mapping from product handle to their respective data URLs
    const handleDataMap = {
      'weekly-pullback-realtest-strategy': {
        newmrUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/weeklydip.json?t=' + Date.now(),
        spyUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/main/public_json/spybenchmark.json?t=' + Date.now(),
        statsUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/weeklydipt_stats.json?t=' + Date.now(),
        extendedUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/weeklydipx.json?t=' + Date.now(),
      },
      'low-drawdown-nasdaq-mean-reversion-realtest-strategy': {
        newmrUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/ndxmr.json?t=' + Date.now(),
        spyUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/main/public_json/spybenchmark.json?t=' + Date.now(),
        statsUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/ndxmrt_stats.json?t=' + Date.now(),
        extendedUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/ndxmrx.json?t=' + Date.now(),
      },
      'all-time-high-mean-reversion-realtest-strategy': {
        newmrUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/athmr.json?t=' + Date.now(),
        spyUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/main/public_json/spybenchmark.json?t=' + Date.now(),
        statsUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/athmrt_stats.json?t=' + Date.now(),
        extendedUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/athmrx.json?t=' + Date.now(),
      },
      'etf-rotation-monthly-rebalance-realtest-strategy': {
        newmrUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/etfrotation.json?t=' + Date.now(),
        spyUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/main/public_json/spybenchmark.json?t=' + Date.now(),
        statsUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/etfrotationt_stats.json?t=' + Date.now(),
        extendedUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/etfrotationx.json?t=' + Date.now(),
      },
      'mean-reversion-2025-realtest-strategy': {
        newmrUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/newmr2025.json?t=' + Date.now(),
        spyUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/main/public_json/spybenchmark.json?t=' + Date.now(),
        statsUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/newmr2025t_stats.json?t=' + Date.now(),
        extendedUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/newmr2025x.json?t=' + Date.now(),
      },
      'modern-breakout-realtest-strategy': {
        newmrUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/breakout.json?t=' + Date.now(),
        spyUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/main/public_json/spybenchmark.json?t=' + Date.now(),
        statsUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/breakoutt_stats.json?t=' + Date.now(),
        extendedUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/breakoutx.json?t=' + Date.now(),
      },
      'nasdaq-100-mean-reversion-realtest-strategy': {
        newmrUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/nasdaq_mr.json?t=' + Date.now(),
        spyUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/main/public_json/spybenchmark.json?t=' + Date.now(),
        statsUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/nasdaq_mrt_stats.json?t=' + Date.now(),
        extendedUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/nasdaq_mrx.json?t=' + Date.now(),
      },
      'parabolic-short-realtest-qullamaggie-strategy': {
        newmrUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/shortsellmr.json?t=' + Date.now(),
        spyUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/main/public_json/spybenchmark.json?t=' + Date.now(),
        statsUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/shortsellmrt_stats.json?t=' + Date.now(),
        extendedUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/shortsellmrx.json?t=' + Date.now(),
      },
      'short-term-mean-reversion-realtest-connors-alvarez': {
        newmrUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/shorttermmr.json?t=' + Date.now(),
        spyUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/main/public_json/spybenchmark.json?t=' + Date.now(),
        statsUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/shorttermmrt_stats.json?t=' + Date.now(),
        extendedUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/shorttermmrx.json?t=' + Date.now(),
      },
      'spx-mean-reversion-realtest-strategy': {
        newmrUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/spxmr.json?t=' + Date.now(),
        spyUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/main/public_json/spybenchmark.json?t=' + Date.now(),
        statsUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/spxmrt_stats.json?t=' + Date.now(),
        extendedUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/spxmrx.json?t=' + Date.now(),
      },
      'realtest-crypto-mean-reversion-strategy': {
        newmrUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/cryptomr.json?t=' + Date.now(),
        spyUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/cryptobenchmark.json?t=' + Date.now(),
        statsUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/cryptomrt.json?t=' + Date.now(),
        extendedUrl: 'https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/cryptomrx.json?t=' + Date.now(),
      },
      // Add more products as needed
    };

    // Default URLs (fallback)
    const defaultUrls = {
      newmrUrl: "https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/main/public_json/nasdaq_mr.json?t=" + Date.now(),
      spyUrl: "https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/main/public_json/spybenchmark.json?t=" + Date.now(),
      statsUrl: "https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/nasdaq_mrt_stats.json?t=" + Date.now(),
      extendedUrl: "https://raw.githubusercontent.com/SaCapitalManagement/CapitalManagementLtd/refs/heads/main/public_json/nasdaq_mrx.json?t=" + Date.now()
    };

    // Get the URLs for the current product handle
    const productHandle = getProductHandle();
    console.log('Product handle:', productHandle);
    const currentUrls = handleDataMap[productHandle] || defaultUrls;
    console.log('Current URLs:', currentUrls);

    // Function to get strategy name from handle
    function getStrategyName(handle) {
      const strategyNames = {
        'weekly-pullback-realtest-strategy': 'Weekly Pullback',
        'low-drawdown-nasdaq-mean-reversion-realtest-strategy': 'Low Drawdown Nasdaq MR',
        'all-time-high-mean-reversion-realtest-strategy': 'All-Time High MR',
        'etf-rotation-monthly-rebalance-realtest-strategy': 'ETF Rotation',
        'mean-reversion-2025-realtest-strategy': 'Mean Reversion 2025',
        'modern-breakout-realtest-strategy': 'Modern Breakout',
        'nasdaq-100-mean-reversion-realtest-strategy': 'Nasdaq 100 MR',
        'parabolic-short-realtest-qullamaggie-strategy': 'Parabolic Short',
        'short-term-mean-reversion-realtest-connors-alvarez': 'Short-Term MR',
        'spx-mean-reversion-realtest-strategy': 'SPX Mean Reversion'
      };
      return strategyNames[handle] || 'Strategy';
    }

    // Benchmark label helper: customize only for crypto strategy
    function getBenchmarkLabel(handle) {
      return handle === 'realtest-crypto-mean-reversion-strategy'
        ? 'Bitcoin Buy & Hold'
        : 'SPY Buy & Hold';
    }

    // Function to calculate and display next month's date range
    function updateNextMonthDates() {
      const now = new Date();
      const currentMonth = now.getMonth();
      const currentYear = now.getFullYear();
      
      // Calculate next month
      let nextMonth = currentMonth + 1;
      let nextYear = currentYear;
      
      if (nextMonth > 11) {
        nextMonth = 0;
        nextYear++;
      }
      
      // Create start and end dates for next month
      const startDate = new Date(nextYear, nextMonth, 1);
      const endDate = new Date(nextYear, nextMonth + 1, 0); // Last day of next month
      
      // Format dates as MM/DD/YY
      const formatDate = (date) => {
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const year = String(date.getFullYear()).slice(-2);
        return `${month}/${day}/${year}`;
      };
      
      const dateRange = `${formatDate(startDate)} - ${formatDate(endDate)}`;
      
      // Update the span element
      const dateSpan = document.getElementById('nextMonthDates');
      if (dateSpan) {
        dateSpan.textContent = dateRange;
      }
    }

    async function fetchJsonOrLog(url, label) {
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
        return await res.json();
      } catch (e) {
        console.error(`Error fetching ${label} from ${url}:`, e);
        throw e;
      }
    }

    let chart = null;

    // Helper function to generate forecast data using month-specific averages
    function generateForecast(startDate, startEquity, monthlyAverages, numMonths) {
      const forecast = [];
      let currentEquity = startEquity;
      let currentDate = new Date(startDate);
      
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      
      console.log('=== FORECAST GENERATION ===');
      console.log('Starting equity:', currentEquity);
      console.log('Starting date:', startDate);
      
      for (let i = 1; i <= numMonths; i++) {
        currentDate = new Date(currentDate);
        currentDate.setMonth(currentDate.getMonth() + 1);
        
        // Get the month (0-11) and use its specific average return
        const month = currentDate.getMonth();
        const monthlyReturnPercent = monthlyAverages[month] || 0;
        
        // Apply monthly return
        const previousEquity = currentEquity;
        currentEquity = currentEquity * (1 + monthlyReturnPercent / 100);
        
        if (i <= 5) { // Log first 5 months
          console.log(`Month ${i} (${monthNames[month]} ${currentDate.getFullYear()}): ${monthlyReturnPercent}% -> $${previousEquity.toFixed(0)} to $${currentEquity.toFixed(0)}`);
        }
        
        forecast.push({
          x: currentDate.toISOString().split('T')[0],
          y: currentEquity
        });
      }
      
      console.log('Final equity after', numMonths, 'months:', currentEquity);
      
      return forecast;
    }

    // Helper function to calculate monthly returns (extracted from generateMonthlyTable)
    function calculateMonthlyReturns(rawData) {
      const validData = rawData.filter(d => d.Date && d.Equity && !isNaN(d.Equity));
      validData.sort((a, b) => new Date(a.Date) - new Date(b.Date));
      
      const cleanedData = validData.map(d => ({
        date: new Date(d.Date),
        equity: parseFloat(d.Equity.toString().replace(/[$,]/g, '').trim())
      }));
      
      const dailyReturns = [];
      for (let i = 1; i < cleanedData.length; i++) {
        const currentEquity = cleanedData[i].equity;
        const previousEquity = cleanedData[i-1].equity;
        if (previousEquity > 0) {
          const dailyReturn = (currentEquity - previousEquity) / previousEquity;
          dailyReturns.push({
            date: cleanedData[i].date,
            return: dailyReturn,
            equity: currentEquity
          });
        }
      }

      const monthlyGroups = {};
      dailyReturns.forEach(dayData => {
        const year = dayData.date.getFullYear();
        const month = dayData.date.getMonth();
        const monthKey = `${year}-${month}`;
        
        if (!monthlyGroups[monthKey]) {
          monthlyGroups[monthKey] = {
            year: year,
            month: month,
            dailyReturns: []
          };
        }
        monthlyGroups[monthKey].dailyReturns.push(dayData.return);
      });

      const monthlyReturns = {};
      Object.values(monthlyGroups).forEach(monthData => {
        if (monthData.dailyReturns.length > 0) {
          const growthFactor = monthData.dailyReturns.reduce((product, dailyReturn) => {
            return product * (1 + dailyReturn);
          }, 1);
          
          const monthlyReturn = growthFactor - 1;
          const monthlyPercent = Math.round(monthlyReturn * 100 * 10) / 10;
          
          if (!monthlyReturns[monthData.year]) {
            monthlyReturns[monthData.year] = {};
          }
          monthlyReturns[monthData.year][monthData.month] = monthlyPercent;
        }
      });

      // Calculate averages, max, and min for each month
      const monthlyAverages = {};
      const monthlyMax = {}; // Actual maximum
      const monthlyMin = {}; // Actual minimum
      
      for (let month = 0; month < 12; month++) {
        let sum = 0;
        let count = 0;
        const monthValues = [];
        
        Object.keys(monthlyReturns).forEach(year => {
          if (monthlyReturns[year][month] !== undefined && monthlyReturns[year][month] !== null) {
            const val = monthlyReturns[year][month];
            sum += val;
            count++;
            monthValues.push(val);
          }
        });
        
        monthlyAverages[month] = count > 0 ? Math.round((sum / count) * 10) / 10 : 0;
        // Use actual max and min values
        monthlyMax[month] = monthValues.length > 0 ? Math.max(...monthValues) : 0;
        monthlyMin[month] = monthValues.length > 0 ? Math.min(...monthValues) : 0;
      }

      return { monthlyReturns, monthlyAverages, monthlyMax, monthlyMin };
    }

    // Function to fetch data and create chart
    async function loadEquityData() {
      try {
        // Show loading state
        const ctx = document.getElementById('equityChart');
        if (!ctx) return;

        const { newmrUrl, spyUrl, statsUrl, extendedUrl } = currentUrls;
        const [meanReversionData, spyData, stats, extended] = await Promise.all([
          fetchJsonOrLog(newmrUrl, 'newmrUrl'),
          fetchJsonOrLog(spyUrl, 'spyUrl'),
          fetchJsonOrLog(statsUrl, 'statsUrl'),
          fetchJsonOrLog(extendedUrl, 'extendedUrl')
        ]);

        // Update statistics panel with dynamic data
        updateStatsPanel(stats, extended);

        // Process the data - format: [{Date: "2000-01-03", Equity: 100178.87}, ...]
        const processData = (data) => {
          return data.filter(d => d.Equity && !isNaN(d.Equity)).map(item => ({
            x: item.Date,
            y: parseFloat(item.Equity)
          }));
        };

        const meanReversionProcessed = processData(meanReversionData);
        const spyProcessed = processData(spyData);

        // Ensure both datasets have the same length and dates
        const minLength = Math.min(meanReversionProcessed.length, spyProcessed.length);
        const meanReversionTrimmed = meanReversionProcessed.slice(0, minLength);
        const spyTrimmed = spyProcessed.slice(0, minLength);

        // Calculate monthly averages, max, and min for forecasting
        const monthlyData = calculateMonthlyReturns(meanReversionData);
        const monthlyAverages = monthlyData.monthlyAverages;
        const monthlyMax = monthlyData.monthlyMax;
        const monthlyMin = monthlyData.monthlyMin;
        
        // Generate forecast data - calculate how many months to forecast
        const lastEquity = meanReversionTrimmed[meanReversionTrimmed.length - 1].y;
        const lastDate = new Date(meanReversionTrimmed[meanReversionTrimmed.length - 1].x);
        const firstDate = new Date(meanReversionTrimmed[0].x);
        
        // Calculate historical span in months
        const historicalMonths = (lastDate - firstDate) / (1000 * 60 * 60 * 24 * 30.44);
        // Dynamically calculate forecast for next 3 years from today
        const now = new Date();
        const threeYearsFromNow = new Date(now);
        threeYearsFromNow.setFullYear(now.getFullYear() + 3);
        const forecastMonths = Math.ceil((threeYearsFromNow - lastDate) / (1000 * 60 * 60 * 24 * 30.44));
        
        console.log('Historical months:', historicalMonths, 'Forecast months:', forecastMonths);
        console.log('Monthly averages (Jan-Dec):', [
          'Jan:', monthlyAverages[0] + '%',
          'Feb:', monthlyAverages[1] + '%',
          'Mar:', monthlyAverages[2] + '%',
          'Apr:', monthlyAverages[3] + '%',
          'May:', monthlyAverages[4] + '%',
          'Jun:', monthlyAverages[5] + '%',
          'Jul:', monthlyAverages[6] + '%',
          'Aug:', monthlyAverages[7] + '%',
          'Sep:', monthlyAverages[8] + '%',
          'Oct:', monthlyAverages[9] + '%',
          'Nov:', monthlyAverages[10] + '%',
          'Dec:', monthlyAverages[11] + '%'
        ]);
        console.log('Last date:', lastDate, 'Last equity:', lastEquity);
        
        // Generate average forecast first (baseline)
        const forecastAvg = generateForecast(lastDate, lastEquity, monthlyAverages, forecastMonths);
        
        // Generate max and min as linear lines from start to Â±50% of avg endpoint
        const forecastMax = [];
        const forecastMin = [];
        
        // Get the endpoint of avg forecast
        const avgEndEquity = forecastAvg[forecastAvg.length - 1].y;
        
        // Calculate max and min endpoints (+100% and -25% from avg endpoint)
        const maxEndEquity = avgEndEquity * 2.0; // +100% above avg end
        const minEndEquity = avgEndEquity * 0.75; // -25% below avg end
        
        console.log('=== MAX/MIN BAND CALCULATION ===');
        console.log(`Starting equity: $${lastEquity.toFixed(0)}`);
        console.log(`Avg forecast end: $${avgEndEquity.toFixed(0)}`);
        console.log(`Max line end: $${maxEndEquity.toFixed(0)} (+100% from avg end)`);
        console.log(`Min line end: $${minEndEquity.toFixed(0)} (-25% from avg end)`);
        
        forecastAvg.forEach((avgPoint, index) => {
          // Progress from 0 to 1
          const progress = forecastAvg.length > 1 ? index / (forecastAvg.length - 1) : 0;
          
          // Exponential interpolation for straight lines on log scale
          // Formula: value = start * (end/start)^progress
          const maxEquity = lastEquity * Math.pow(maxEndEquity / lastEquity, progress);
          const minEquity = lastEquity * Math.pow(minEndEquity / lastEquity, progress);
          
          if (index === 0 || index === forecastAvg.length - 1) { // Log first and last
            console.log(`Month ${index + 1}: Progress=${(progress*100).toFixed(0)}%, Avg=$${avgPoint.y.toFixed(0)}, Max=$${maxEquity.toFixed(0)}, Min=$${minEquity.toFixed(0)}`);
          }
          
          forecastMax.push({
            x: avgPoint.x,
            y: maxEquity
          });
          
          forecastMin.push({
            x: avgPoint.x,
            y: minEquity
          });
        });

        // Prepare data with actual dates (not labels)
        // No need for labels array - we'll use time scale

        // Register vertical line plugin
        const verticalLinePlugin = {
          id: 'verticalLine',
          beforeDraw: (chart) => {
            if (chart.tooltip?._active && chart.tooltip._active.length) {
              const activePoint = chart.tooltip._active[0];
              const ctx = chart.ctx;
              const x = activePoint.element.x;
              const topY = chart.scales.y.top;
              const bottomY = chart.scales.y.bottom;

              ctx.save();
              ctx.beginPath();
              ctx.setLineDash([3, 3]);
              ctx.moveTo(x, topY);
              ctx.lineTo(x, bottomY);
              ctx.lineWidth = 1;
              ctx.strokeStyle = '#9ca3af';
              ctx.stroke();
              ctx.restore();
            }
          }
        };

        // Get strategy name for legend
        const strategyName = getStrategyName(productHandle);

        // Prepare data arrays with {x, y} format for time scale
        const strategyChartData = meanReversionTrimmed.map(item => ({
          x: new Date(item.x),
          y: item.y
        }));
        
        const spyChartData = spyTrimmed.map(item => ({
          x: new Date(item.x),
          y: item.y
        }));
        
        const forecastAvgData = [
          { x: lastDate, y: lastEquity }, // Start from last historical point
          ...forecastAvg.map(item => ({
            x: new Date(item.x),
            y: item.y
          }))
        ];
        
        const forecastMaxData = [
          { x: lastDate, y: lastEquity },
          ...forecastMax.map(item => ({
            x: new Date(item.x),
            y: item.y
          }))
        ];
        
        const forecastMinData = [
          { x: lastDate, y: lastEquity },
          ...forecastMin.map(item => ({
            x: new Date(item.x),
            y: item.y
          }))
        ];

        // Create the chart
        if (typeof Chart !== 'undefined') {
          Chart.register(verticalLinePlugin);
          // Plugin: Shade forecast region with vertical divider and label
          const forecastShadePlugin = {
            id: 'forecastShade',
            afterDraw: (chartInstance) => {
              const ctx = chartInstance.ctx;
              const xScale = chartInstance.scales.x;
              const yScale = chartInstance.scales.y;
              if (!xScale || !yScale) return;

              // Forecast starts at last historical date (lastDate)
              const forecastStartX = xScale.getPixelForValue(lastDate);
              const chartTop = yScale.top;
              const chartBottom = yScale.bottom;

              // Shade area to the right (forecast period)
              ctx.save();
              ctx.fillStyle = 'rgba(156, 163, 175, 0.10)'; // gray-400 @10%
              ctx.fillRect(forecastStartX, chartTop, chartInstance.chartArea.right - forecastStartX, chartBottom - chartTop);

              // Vertical divider line
              ctx.beginPath();
              ctx.moveTo(forecastStartX, chartTop);
              ctx.lineTo(forecastStartX, chartBottom);
              ctx.lineWidth = 1;
              ctx.strokeStyle = 'rgba(156, 163, 175, 0.8)';
              ctx.stroke();

              // Label 'Forecast'
              ctx.fillStyle = 'rgba(107, 114, 128, 0.9)';
              ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
              ctx.textAlign = 'left';
              ctx.fillText('3Y Forecast', forecastStartX + 6, chartBottom-12);
              ctx.restore();
            }
          };

          Chart.register(forecastShadePlugin);
          chart = new Chart(ctx, {
            type: 'line',
            data: {
              datasets: [
                {
                  label: strategyName,
                  data: strategyChartData,
                  borderColor: '#22c55e',
                  backgroundColor: 'rgba(34, 197, 94, 0.1)',
                  borderWidth: 1.5,
                  fill: false,
                  tension: 0.1,
                  pointRadius: 0,
                  pointHoverRadius: 3
                },
                {
                  label: getBenchmarkLabel(productHandle),
                  data: spyChartData,
                  borderColor: '#ef4444',
                  backgroundColor: 'rgba(239, 68, 68, 0.1)',
                  borderWidth: 1.5,
                  fill: true,
                  tension: 0.1,
                  pointRadius: 0,
                  pointHoverRadius: 3
                },
                {
                  label: 'Max Forecast',
                  data: forecastMaxData,
                  borderColor: '#9ca3af',
                  backgroundColor: 'rgba(34, 197, 94, 0.15)',
                  borderWidth: 0.5,
                  fill: '+1', // Fill to next dataset (avg forecast) with green
                  tension: 0,
                  pointRadius: 0,
                  pointHoverRadius: 2,
                  hidden: false
                },
                {
                  label: 'Avg Forecast',
                  data: forecastAvgData,
                  borderColor: '#10b981',
                  backgroundColor: 'rgba(239, 68, 68, 0.15)',
                  borderWidth: 1.5,
                  fill: '+1', // Fill to next dataset (min forecast) with red
                  tension: 0.1,
                  pointRadius: 0,
                  pointHoverRadius: 3,
                  hidden: false
                },
                {
                  label: 'Min Forecast',
                  data: forecastMinData,
                  borderColor: '#9ca3af',
                  backgroundColor: 'transparent',
                  borderWidth: 0.5,
                  fill: false,
                  tension: 0,
                  pointRadius: 0,
                  pointHoverRadius: 2,
                  hidden: false
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              devicePixelRatio: 1,
              plugins: {
                legend: {
                  position: 'top',
                  onClick: (e, legendItem, legend) => {
                    const index = legendItem.datasetIndex;
                    const chartInstance = legend.chart;
                    const dataset = chartInstance.data.datasets[index];

                    // Toggle base dataset visibility
                    dataset.hidden = !dataset.hidden;

                    // If Strategy toggled, link forecast datasets to it
                    if (dataset.label === strategyName) {
                      chartInstance.data.datasets.forEach(ds => {
                        if (ds.label && ds.label.includes('Forecast')) {
                          ds.hidden = dataset.hidden;
                        }
                      });
                    }

                    chartInstance.update();
                  },
                  labels: {
                    fontSize: 12,
                    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                    usePointStyle: true,
                    pointStyle: 'rect',
                    padding: 15,
                    filter: function(item, chart) {
                      // Hide forecast datasets from legend
                      return !item.text.includes('Forecast');
                    }
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                  backgroundColor: 'rgba(255, 255, 255, 0.95)',
                  titleColor: '#374151',
                  bodyColor: '#374151',
                  borderColor: '#e5e7eb',
                  borderWidth: 1,
                  cornerRadius: 6,
                  displayColors: true,
                  callbacks: {
                    title: function(tooltipItems) {
                      if (tooltipItems[0].parsed.x) {
                        const date = new Date(tooltipItems[0].parsed.x);
                        return date.toLocaleDateString('en-US', { 
                          year: 'numeric', 
                          month: 'short', 
                          day: 'numeric' 
                        });
                      }
                      return '';
                    },
                    label: function(context) {
                      const value = context.parsed.y;
                      const formattedValue = value >= 1000000 ? 
                        '$' + (value / 1000000).toFixed(1) + 'M' : 
                        '$' + (value / 1000).toFixed(0) + 'K';
                      return context.dataset.label + ': ' + formattedValue;
                    }
                  }
                }
              },
              scales: {
                x: {
                  type: 'time',
                  time: {
                    unit: 'year',
                    displayFormats: {
                      year: 'yy'
                    },
                    tooltipFormat: 'MMM dd, yyyy'
                  },
                  display: true,
                  title: {
                    display: false
                  },
                  ticks: {
                    font: {
                      size: 10
                    },
                    maxRotation: 0,
                    autoSkip: true
                  },
                  grid: {
                    color: '#f3f4f6',
                    drawBorder: false
                  }
                },
                y: {
                  display: true,
                  type: 'logarithmic',
                  title: {
                    display: false
                  },
                  ticks: {
                    callback: function(value) {
                      if (value >= 1000000) {
                        return '$' + (value / 1000000).toFixed(0) + 'M';
                      } else if (value >= 100000) {
                        return '$' + (value / 1000).toFixed(0) + 'K';
                      }
                      return '$' + value.toLocaleString();
                    },
                    font: {
                      size: 10
                    }
                  },
                  grid: {
                    color: '#f3f4f6',
                    drawBorder: false
                  }
                }
              },
              interaction: {
                mode: 'index',
                axis: 'x',
                intersect: false
              },

              elements: {
                line: {
                  tension: 0.1
                }
              }
            }
          });
        }

        // Generate monthly table using compounded daily returns formula
        generateMonthlyTable(meanReversionData);

      } catch (error) {
        console.error('Error loading equity data:', error);
        // Fallback to show error message
        const ctx = document.getElementById('equityChart');
        if (ctx) {
          const parent = ctx.parentElement;
          parent.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 400px; color: #ef4444; font-size: 14px;">Failed to load chart data. Please check your connection.</div>';
        }
      }
    }

         // Function to update statistics panel with dynamic data
     function updateStatsPanel(stats, extended) {
       const statPanel = document.getElementById("statsPanel");
       
       // Parse numbers from extended data
       function parseNumber(str) {
         if (!str) return 0;
         return Number(str.toString().replace(/,/g, '')) || 0;
       }
       
       function formatNumber(num) {
         return num.toLocaleString(undefined, { maximumFractionDigits: 0 });
       }
       
      // Removed paid commissions per user request
      let sumDividends = parseNumber(extended.sum_dividends);
       if (sumDividends <= 0) sumDividends = 0;
       const avgBars = extended.avg_bars || 'n/a';

               // Calculate total return percentage from NetProfit
        const netProfit = parseNumber(stats.NetProfit);
        const totalReturn = ((netProfit / 100000) * 100).toFixed(1); // Assuming starting with $100K
        const formattedTotalReturn = parseFloat(totalReturn).toLocaleString('en-US', { minimumFractionDigits: 1, maximumFractionDigits: 1 });

       // Calculate winning trades from PctWins
       const totalTrades = parseNumber(stats.Trades);
       const winRate = parseFloat(stats.PctWins);
       const winningTrades = Math.round((totalTrades * winRate) / 100);

       // Determine frequency text based on total trades
       let frequencyText = '';
       if (totalTrades < 100) {
         frequencyText = 'Low frequency execution';
       } else if (totalTrades <= 1000) {
         frequencyText = 'Medium frequency execution';
       } else {
         frequencyText = 'High frequency execution';
       }

       // Determine momentum text
       const avgHoldingDays = parseInt(avgBars) || 6;
       const momentumText = avgHoldingDays < 10 ? 'Short-term momentum' : 'Long-term momentum';

             statPanel.innerHTML = `
         <div class="stats-grid">
           <!-- Net Profit -->
           <div class="stat-item">
             <div class="stat-label">Net Profit</div>
             <div class="stat-value positive">$${stats.NetProfit}</div>
                           <div class="stat-sublabel">+${formattedTotalReturn}% total return</div>
           </div>

           <!-- Total Trades -->
           <div class="stat-item">
             <div class="stat-label">Total Trades</div>
             <div class="stat-value">${stats.Trades}</div>
             <div class="stat-sublabel">${frequencyText}</div>
           </div>

           <!-- Max Drawdown -->
           <div class="stat-item">
             <div class="stat-label">Max Drawdown</div>
             <div class="stat-value negative">-${Math.abs(stats.Drawdown)}%</div>
             <div class="stat-sublabel">Controlled risk exposure</div>
           </div>

           <!-- Expectancy -->
           <div class="stat-item">
             <div class="stat-label">Expectancy</div>
             <div class="stat-value">${stats.Expectancy}</div>
             <div class="stat-sublabel">Average trade profit</div>
           </div>

           <!-- Sharpe Ratio -->
           <div class="stat-item">
             <div class="stat-label">Sharpe Ratio</div>
             <div class="stat-value">${stats.Sharpe}</div>
             <div class="stat-sublabel">Risk-adjusted return</div>
           </div>

           <!-- MAR Ratio -->
           <div class="stat-item">
             <div class="stat-label">MAR Ratio</div>
             <div class="stat-value">${stats.MAR}</div>
           </div>

           <!-- Win % -->
           <div class="stat-item">
             <div class="stat-label">Win %</div>
             <div class="stat-value">${stats.PctWins}</div>
             <div class="stat-sublabel">${winningTrades.toLocaleString()} winning trades</div>
           </div>

           <!-- Max Exposure -->
           <div class="stat-item">
             <div class="stat-label">Max Exposure</div>
             <div class="stat-value">${stats.MaxExposure}%</div>
           </div>

           <!-- Earned Dividends -->
           <div class="stat-item">
             <div class="stat-label">Earned Dividends</div>
             <div class="stat-value">$${formatNumber(sumDividends)}</div>
             <div class="stat-sublabel">Passive income generated</div>
           </div>

                       <!-- Avg Holding Days -->
            <div class="stat-item">
              <div class="stat-label">Avg Holding Days</div>
              <div class="stat-value">${avgBars}</div>
              <div class="stat-sublabel">${momentumText}</div>
            </div>

                      </div>
       `;
    }

    // Generate monthly table using compounded daily returns formula
    async function generateMonthlyTable(rawData) {
      try {
        // Step 1: Calculate daily returns (exactly like Python pandas pct_change())
        const validData = rawData.filter(d => d.Date && d.Equity && !isNaN(d.Equity));
        validData.sort((a, b) => new Date(a.Date) - new Date(b.Date));
        
        // Clean equity values (remove $, commas, spaces) and convert to float
        const cleanedData = validData.map(d => ({
          date: new Date(d.Date),
          equity: parseFloat(d.Equity.toString().replace(/[$,]/g, '').trim())
        }));
        
        // Calculate daily returns using pct_change() method (same as Python)
        const dailyReturns = [];
        for (let i = 1; i < cleanedData.length; i++) {
          const currentEquity = cleanedData[i].equity;
          const previousEquity = cleanedData[i-1].equity;
          if (previousEquity > 0) {
            const dailyReturn = (currentEquity - previousEquity) / previousEquity; // This is pct_change()
            dailyReturns.push({
              date: cleanedData[i].date,
              return: dailyReturn,
              equity: currentEquity
            });
          }
        }

        // Step 2: Group daily returns by year and month
        const monthlyGroups = {};
        const yearlyGroups = {};
        
        dailyReturns.forEach(dayData => {
          const year = dayData.date.getFullYear();
          const month = dayData.date.getMonth(); // 0-11
          const monthKey = `${year}-${month}`;
          
          // Group by month
          if (!monthlyGroups[monthKey]) {
            monthlyGroups[monthKey] = {
              year: year,
              month: month,
              dailyReturns: []
            };
          }
          monthlyGroups[monthKey].dailyReturns.push(dayData.return);
          
          // Group by year
          if (!yearlyGroups[year]) {
            yearlyGroups[year] = {
              dailyReturns: []
            };
          }
          yearlyGroups[year].dailyReturns.push(dayData.return);
        });

        // Step 3: Calculate monthly returns (compounded from daily)
        const monthlyReturns = {};
        Object.values(monthlyGroups).forEach(monthData => {
          if (monthData.dailyReturns.length > 0) {
            // GrowthFactor_M = product over t in M of (1 + R[t])
            const growthFactor = monthData.dailyReturns.reduce((product, dailyReturn) => {
              return product * (1 + dailyReturn);
            }, 1);
            
            // MonthlyReturn_M = GrowthFactor_M - 1
            const monthlyReturn = growthFactor - 1;
            
            // MonthlyPercent_M = round(MonthlyReturn_M * 100, 1)
            const monthlyPercent = Math.round(monthlyReturn * 100 * 10) / 10;
            
            if (!monthlyReturns[monthData.year]) {
              monthlyReturns[monthData.year] = {};
            }
            monthlyReturns[monthData.year][monthData.month] = monthlyPercent;
          }
        });

        // Step 4: Calculate yearly returns (compounded from daily)
        Object.keys(yearlyGroups).forEach(year => {
          const yearData = yearlyGroups[year];
          if (yearData.dailyReturns.length > 0) {
            // GrowthFactor_Y = product over t in Y of (1 + R[t])
            const growthFactor = yearData.dailyReturns.reduce((product, dailyReturn) => {
              return product * (1 + dailyReturn);
            }, 1);
            
            // YearlyReturn_Y = GrowthFactor_Y - 1
            const yearlyReturn = growthFactor - 1;
            
            // YearlyPercent_Y = round(YearlyReturn_Y * 100, 1)
            const yearlyPercent = Math.round(yearlyReturn * 100 * 10) / 10;
            
            if (!monthlyReturns[year]) {
              monthlyReturns[year] = {};
            }
            monthlyReturns[year].annual = yearlyPercent;
          }
        });

        // Step 5: Calculate max drawdown for each year
        const years = Object.keys(monthlyReturns).sort();
        years.forEach(year => {
          let maxDrawdown = 0;
          let peak = 0;
          
          // Find the peak and calculate drawdown from daily returns
          dailyReturns.forEach(dayData => {
            if (dayData.date.getFullYear() === parseInt(year)) {
              if (dayData.equity > peak) {
                peak = dayData.equity;
              }
              const drawdown = ((peak - dayData.equity) / peak) * 100;
              if (drawdown > maxDrawdown) {
                maxDrawdown = drawdown;
              }
            }
          });
          
          monthlyReturns[year].maxDrawdown = Math.round(maxDrawdown * 10) / 10;
        });

        // Calculate averages
        const monthlyAverages = {};
        let totalAnnualReturn = 0;
        let totalMaxDrawdown = 0;
        let validYears = 0;

        for (let month = 0; month < 12; month++) {
          let sum = 0;
          let count = 0;
          years.forEach(year => {
            if (monthlyReturns[year][month] !== undefined && monthlyReturns[year][month] !== null) {
              sum += monthlyReturns[year][month];
              count++;
            }
          });
          monthlyAverages[month] = count > 0 ? Math.round((sum / count) * 10) / 10 : 0;
        }

        years.forEach(year => {
          if (monthlyReturns[year].annual !== undefined) {
            totalAnnualReturn += monthlyReturns[year].annual;
            totalMaxDrawdown += monthlyReturns[year].maxDrawdown;
            validYears++;
          }
        });

                 const avgAnnualReturn = validYears > 0 ? Math.round((totalAnnualReturn / validYears) * 10) / 10 : 0;
         const avgMaxDrawdown = validYears > 0 ? Math.round((totalMaxDrawdown / validYears) * 10) / 10 : 0;

                             // Calculate forecast for next month based on latest equity value
          const avgMonthlyReturn = Object.values(monthlyAverages).reduce((sum, avg) => sum + avg, 0) / 12;
          
          // Get the latest equity value from the data
          const latestEquity = cleanedData.length > 0 ? cleanedData[cleanedData.length - 1].equity : 100000;
          const forecastAmount = Math.round((avgMonthlyReturn / 100) * latestEquity);
          const forecastAmount100k = Math.round((avgMonthlyReturn / 100) * 100000);
          
      // Removed forecast banner DOM updates

         // Generate HTML table with exact styling
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        let tableHTML = `
          <table class="monthly-table">
            <thead>
              <tr>
                <th>YEAR</th>
                ${months.map(month => `<th>${month}</th>`).join('')}
                <th>TOTAL</th>
                <th>MaxDD</th>
              </tr>
            </thead>
            <tbody>
        `;

        // Add data rows
        years.forEach(year => {
          tableHTML += `<tr>`;
          tableHTML += `<td class="year-column">${year}</td>`;
          
          months.forEach((month, index) => {
            const value = monthlyReturns[year][index];
            let cellClass = '';
            let displayValue = 'n/a';
            
            if (value !== undefined && value !== null && !isNaN(value)) {
              displayValue = `${value.toFixed(1)}%`;
              cellClass = value < 0 ? 'gain-negative' : 'gain-positive';
            }
            
            tableHTML += `<td class="${cellClass}">${displayValue}</td>`;
          });
          
          // Total column
          const totalValue = monthlyReturns[year].annual;
          let totalClass = '';
          let totalDisplay = 'n/a';
          
          if (totalValue !== undefined && totalValue !== null && !isNaN(totalValue)) {
            totalDisplay = `${totalValue.toFixed(1)}%`;
            totalClass = totalValue < 0 ? 'gain-negative' : 'gain-positive';
          }
          
          tableHTML += `<td class="total-column ${totalClass}">${totalDisplay}</td>`;
          
          // MaxDD column (always black text)
          const maxDDValue = monthlyReturns[year].maxDrawdown;
          let maxDDDisplay = 'n/a';
          if (maxDDValue !== undefined && !isNaN(maxDDValue)) {
            maxDDDisplay = `-${maxDDValue.toFixed(1)}%`;
          }
          
          tableHTML += `<td class="maxdd-column">${maxDDDisplay}</td>`;
          tableHTML += `</tr>`;
        });

        // Add AVG row
        tableHTML += `
          <tr class="avg-row">
            <td class="year-column">AVG</td>
            ${months.map((month, index) => `<td>${monthlyAverages[index].toFixed(1)}%</td>`).join('')}
            <td class="total-column">${avgAnnualReturn.toFixed(1)}%</td>
            <td class="maxdd-column">-${avgMaxDrawdown.toFixed(1)}%</td>
          </tr>
        `;

        tableHTML += `
            </tbody>
          </table>
        `;

        document.getElementById('monthlyTablePanel').innerHTML = tableHTML;
        console.log('Generated monthly table with dynamic data');

      } catch (error) {
        console.error('Error generating monthly table:', error);
        document.getElementById('monthlyTablePanel').innerHTML = `
          <div class="loading">Error generating monthly performance table from data source.</div>
        `;
      }
    }

    // Load data when page loads
    document.addEventListener('DOMContentLoaded', function() {
      // Update next month dates
      updateNextMonthDates();
      
      if (typeof Chart !== 'undefined') {
        loadEquityData();
      } else {
        console.error('Chart.js not loaded');
      }
    });
  </script>
</body>
</html>
